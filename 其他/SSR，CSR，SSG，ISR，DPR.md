

https://blog.csdn.net/Tencent_TEG/article/details/116617151


### SSR 和CSR 
简而言之，就是数据拼接HTML字符串这件事放在服务端还是客户端造成了两者区别。

SSR(Server Side Rendering) ：传统的渲染方式，由服务端把渲染的完整的页面吐给客户端。这样减少了一次客户端到服务端的一次http请求，加快相应速度，一般用于首屏的性能优化。


CSR(Client Side Rendering)：是一种目前流行的渲染方式，它依赖的是运行在客户端的JS，用户首次发送请求只能得到小部分的指引性HTML代码。第二次请求将会请求更多包含HTML字符串的JS文件。

<img src="https://pic4.zhimg.com/80/v2-98c7d2c7974a1aa694203e3135531e3b_1440w.jpg">

从以上表格来看，两者方案的优点和确定但很明显，SSR更有利于首屏渲染，CSR更有利于页面交互。
### SSR --问题
1、需要服务器的计算资源和公网流量来部署这套服务，并且消耗的资源与页面的访问量成正相关，当页面的访问量突增时，渲染服务也需要进行扩容；

2、服务端只能部署在有限的几个地域，对于距离服务端较远的用户而言，加载速度跟静态资源的 CDN 相比，慢了一个数量级（通常是 1-5ms VS 50-100+ms）；

3、日常也存在传统服务端同样的运维、监控告警等方面的负担，团队需要额外的人力来开发和维护。
#### 注意
* Vue的生命周期钩子函数中， 只有 beforeCreate 和 created 会在服务器端渲染(SSR)过程中被调用，这就是说在这两个钩子函数中的代码以及除了vue生命周期钩子函数的全局代码，都将会在服务端和客户端两套环境下执行。
在beforeCreate，created生命周期以及全局的执行环境中调用特定的api前需要判断执行环境

* 在客户端到SSR服务器的请求中，客户端是携带有cookie数据的。但是在SSR服务器请求后端接口的过程中，却是没有相应的cookie数据的。因此在SSR服务器进行接口请求的时候，我们需要手动拿到客户端的cookie传给后端服务器。

* vue有两种路由模式，一种是hash模式，就是我们经常用的#/hasha/hashb这种，还有一种是history模式，就是/historya/historyb这种。因为hash模式的路由提交不到服务器上，因此ssr的路由需要采用history的方式。
#### 有没有办法解决这些问题呢？-- SSG

我们重新对 SSR 进行审视，服务端渲染出的页面，逻辑上讲可以分成下面两大块：

1、变化不频繁，甚至不会变化的内容：例如文章、排行榜、商品信息、推荐列表等等，这些数据非常适合缓存；

2、变化比较频繁，或者千人千面的内容：例如用户头像、Timeline、登录状态、实时评论等。

例如，在一篇文章的页面中，文章的主题内容是偏向于静态的，很少有改动，那么每次用户的页面请求，都通过服务端来渲染就变得非常不值得，因为每次服务端渲染出来大部分内容都是一样的！

我们完全可以将文章的页面渲染为静态页面，至于页面内那些动态的内容（用户头像、评论框等），就通过 HTTP API 的形式进行浏览器端渲染（CSR）

#### 这样做有很多好处：

1、由于文章内容已经被静态化了，所以它是 SEO 友好的，能被搜索引擎轻松爬取；

2、大大减轻了服务端渲染的资源负担，不需要额外做一套 Node.js 服务；

3、用户始终通过 CDN 加载页面核心内容，CDN 的边缘节点有缓存，速度极快；

4、通过 HTTP API + CSR，页面内次要的动态内容也可以被很好地渲染；

5、数据有变化时，重新触发一次网站的异步渲染，然后推送新的内容到 CDN 即可。

6、由于每次都是全站渲染，所以网站的版本可以很好的与 Git 的版本对应上，甚至可以做到原子化发布和回滚。


### SSG 页面静态化（静态页面生成），把 PHP 提前渲染成 HTML---(Static Site Generation) 

前提:

如果每个人都请求一个相同的资源，比如都请求相同的文章列表，那还需要在每个人的浏览器上渲染一次吗？直觉告诉我们是不是大可不必，可以直接在后端渲染好，然后每个人直接读取后端传来的内容。

n次渲染变成了一次渲染，n次客户端渲染变成了1次静态页面生成。这个过程叫做动态内容静态化。

*  后端数据可以直接传给前端 -- 相当于把所有字段吐到模板上
<img src="https://pic3.zhimg.com/80/v2-1c4c6d4165b1eef6565d7f160b8e6f92_1440w.jpg">

优缺点

优点：这种方式可以解决白屏问题、SEO 问题

缺点：所有用户看到的都是同一个页面，无法生成用户相关内容


##### SSG静态化的优点：

生产环境中直接给出完整页面
首屏不会白屏
搜索引擎能看到页面内容，方便SEO


##### 动态内容静态化

如果动态内容与用户无关，那么可以提前静态化
通过 getStaticProps 可以获取数据
静态内容+数据(本地获取) 就得到了完整的页面
代替了之前的 静态内容+动态内容(AJAX 获取)


####  BSR  - 用 JS、Vue、React 创建 HTML （ (Broswer Side Render)）

#### ISR：Incremental Site Rendering，增量式的网站渲染；

#### DPR Distributed Persistent Rendering，分布式的持续渲染。

#### 从 SSG 到 ISR/DPR

细心的同学一定发现了 SSG 这样的模式，看似美好，但存在一个瑕疵：

对于只有几十个页面的个人博客、小型文档站而言，数据有变化时，跑一次全页面渲染的消耗是可以接受的。

但对于百万级、千万级、亿级页面的大型网站而言，一旦有数据改动，要进行一次全部页面的渲染，需要的时间可能是按小时甚至按天计的，这是不可接受的。

为了解决这个问题，各种框架和静态网站托管平台都提供了不同的方案，这里我们介绍 ISR 和 DPR 两种。

既然全量预渲染整个网站是不现实的，那么我们可以做一个切分：

1、关键性的页面（如网站首页、热点数据等）预渲染为静态页面，缓存至 CDN，保证最佳的访问性能；

2、非关键性的页面（如流量很少的老旧内容）先响应 fallback 内容，然后浏览器渲染（CSR）为实际数据；同时对页面进行异步预渲染，之后缓存至 CDN，提升后续用户访问的性能。

页面的更新遵循 stale-while-revalidate 的逻辑，即始终返回 CDN 的缓存数据（无论是否过期）；如果数据已经过期，那么触发异步的预渲染，异步更新 CDN 的缓存。
##### 但 ISR 存在部分缺陷：

1、对于没有预渲染的页面，用户首次访问将会看到一个 fallback 页面，此时服务端才开始渲染页面，直到渲染完毕。这就导致用户体验上的不一致。

2、对于已经被预渲染的页面，用户直接从 CDN 加载，但这些页面可能是已经过期的，甚至过期很久的，只有在用户刷新一次，第二次访问之后，才能看到新的数据。对于电商这样的场景而言，是不可接受的（比如商品已经卖完了，但用户看到的过期数据上显示还有）。
#### 为了解决 ISR 的一系列问题，Netlify 在前段时间发起了一个新的提案：-DPR
1、去除了 fallback 行为，而是直接用 On-demand Builder（按需构建器）来响应未经过预渲染的页面，然后将结果缓存至 CDN；

2、数据页面过期时，不再响应过期的缓存页面，而是 CDN 回源到 Builder 上，渲染出最新的数据；

3、每次发布新版本时，自动清除 CDN 的缓存数据。

#### 总结

客户端渲染 CSR
* 只在浏览器上运行，缺点 SEO 不友好，白屏

静态页面生成 SSG

* Static Site Generation，解决白屏问题、SEO 问题

* 缺点：无法生成和用户相关的内容 （所有用户请求的结果都一样）

服务端渲染 （SSR）

* 解决白屏问题、SEO问题

*可以生成用户相关的内容

