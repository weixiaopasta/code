#### 贪心算法 - 数字拼接的问题

再来看一个贪心算法的问题，加深下理解，这个问题如下：

<img src="http://www.dennisgo.cn/images/DataStructureAndAlgorithm/Greedy/image-20200220153438242.png">

这个问题看起来也不难，我们有时候也会遇到类似的问题，我们可以很直观的想到一个解法：看哪个数字的第一个数字大，把他排前面，比如32和94，把第一位是9的94放前面，得到9432，肯定比32放前面的3294大。这其实就是按照字符串大小来排序嘛，字符大的排前面，但是这种解法正确吗？我们再来看两个数字，假如我们有728和7286，按照字符序，7286排前面，得到7286728，但是这个值没有728放前面的7287286大。说明单纯的字符序是搞不定这个的，对于两个数字a,b，如果他们的长度一样，那按照字符序就没问题，如果他们长度不一样，这个解法就不一定对了，那怎么办呢？其实也简单，我们看看a+b和b+a拼成的数字，哪个大就行了。
```
假设
a = 728
b = 7286
字符串： a + b = "7287286"
字符串： b + a = "7286728"
比较下这两个字符串, a + b比较大，a放前面就行了, 反之放到后面

```
上述算法就是一个贪心，这里贪的是什么的？贪的是a + b的值，要大的那个。在实现的时候，可以自己写个冒泡，也可以直接用数组的sort方法:


```
const nums = [32, 94, 128, 1286, 6, 71];

function getBigNum(nums) {
  nums.sort((a, b) => {
    const ab = `${a}${b}`;
    const ba = `${b}${a}`;

    if(ab > ba) {
      return -1;   // ab大，a放前面
    } else if (ab < ba) {
      return 1;  
    }

    return 0;
  });

  return nums;
}

const res = getBigNum(nums);
console.log(res);    // [94, 71, 6, 32, 1286, 128]
```